# V8引擎

![1xdz07](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/1xdz07.png)

JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。

为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：

源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎在2017年之前没有中间字节码)。

先前V8采用更加激进的方式，将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。

但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度。

## 工作原理

V8由许多子模块构成，其中这4个模块是最重要的：

- Parser：负责将JavaScript源码转换为Abstract Syntax Tree (AST)
- Ignition：interpreter，即解释器，负责将AST转换为Bytecode，解释执行Bytecode；同时收集TurboFan优化编译所需的信息，比如函数参数的类型；
- TurboFan：compiler，即编译器，利用Ignitio所收集的类型信息，将Bytecode转换为优化的汇编代码；
- Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收；

其中，Parser，Ignition以及TurboFan可以将JS源码编译为汇编代码，其流程图如下：

![Wmara7](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/Wmara7.jpg)

简单地说，Parser将JS源码转换为AST，然后Ignition将AST转换为Bytecode，最后TurboFan将Bytecode转换为经过优化的Machine Code(实际上是汇编代码)。

- 如果函数没有被调用，则V8不会去编译它。
- 如果函数只被调用1次，则Ignition将其编译Bytecode就直接解释执行了。TurboFan不会进行优化编译，因为它需要Ignition收集函数执行时的类型信息。这就要求函数至少需要执行1次，TurboFan才有可能进行优化编译。
- 如果函数被调用多次，则它有可能会被识别为热点函数，且Ignition收集的类型信息证明可以进行优化编译的话，这时TurboFan则会将Bytecode编译为Optimized Machine Code，以提高代码的执行性能。

图片中的红线是逆向的，这的确有点奇怪，Optimized Machine Code会被还原为Bytecode，这个过程叫做Deoptimization。这是因为Ignition收集的信息可能是错误的，比如add函数的参数之前是整数，后来又变成了字符串。生成的Optimized Machine Code已经假定add函数的参数是整数，那当然是错误的，于是需要进行Deoptimization。

```js
function add(x, y) {
    return x + y;
}

add(1, 2);
add("1", "2");
```

在运行C、C++以及Java等程序之前，需要进行编译，不能直接执行源码；但对于JavaScript来说，我们可以直接执行源码(比如：node server.js)，它是在运行的时候先编译再执行，这种方式被称为即时编译(Just-in-time compilation)，简称为JIT。因此，V8也属于JIT编译器。

## Ignition：解释器

Node.js是基于V8引擎实现的，因此node命令提供了很多V8引擎的选项，使用node的--print-bytecode选项，可以打印出Ignition生成的Bytecode。

factorial.js如下，由于V8不会编译没有被调用的函数，因此需要在最后一行调用factorial函数。

```js
function factorial(N) {
    if (N === 1) {
        return 1;
    } else {
        return N * factorial(N - 1);
    }
}

factorial(10); // V8不会编译没有被调用的函数，因此这一行不能省略
```

使用node命令(node版本为12.6.0)的--print-bytecode选项，打印出Ignition生成的Bytecode：

node --print-bytecode factorial.js
控制台输出的内容非常多，最后一部分是factorial函数的Bytecode：

```text
[generated bytecode for function: factorial]
Parameter count 2
Register count 3
Frame size 24
   18 E> 0x3541c2da112e @    0 : a5                StackCheck
   28 S> 0x3541c2da112f @    1 : 0c 01             LdaSmi [1]
   34 E> 0x3541c2da1131 @    3 : 68 02 00          TestEqualStrict a0, [0]
         0x3541c2da1134 @    6 : 99 05             JumpIfFalse [5] (0x3541c2da1139 @ 11)
   51 S> 0x3541c2da1136 @    8 : 0c 01             LdaSmi [1]
   60 S> 0x3541c2da1138 @   10 : a9                Return
   82 S> 0x3541c2da1139 @   11 : 1b 04             LdaImmutableCurrentContextSlot [4]
         0x3541c2da113b @   13 : 26 fa             Star r1
         0x3541c2da113d @   15 : 25 02             Ldar a0
  105 E> 0x3541c2da113f @   17 : 41 01 02          SubSmi [1], [2]
         0x3541c2da1142 @   20 : 26 f9             Star r2
   93 E> 0x3541c2da1144 @   22 : 5d fa f9 03       CallUndefinedReceiver1 r1, r2, [3]
   91 E> 0x3541c2da1148 @   26 : 36 02 01          Mul a0, [1]
  110 S> 0x3541c2da114b @   29 : a9                Return
Constant pool (size = 0)
Handler Table (size = 0)
```

生成的Bytecode其实挺简单的：

- 使用LdaSmi命令将整数1保存到寄存器；
- 使用TestEqualStrict命令比较参数a0与1的大小；
- 如果a0与1相等，则JumpIfFalse命令不会跳转，继续执行下一行代码；
- 如果a0与1不相等，则JumpIfFalse命令会跳转到内存地址0x3541c2da1139
- ...

不难发现，Bytecode某种程度上就是汇编语言，只是它没有对应特定的CPU，或者说它对应的是虚拟的CPU。这样的话，生成Bytecode时简单很多，无需为不同的CPU生产不同的代码。要知道，V8支持9种不同的CPU，引入一个中间层Bytecode，可以简化V8的编译流程，提高可扩展性。

具体为何要使用Ignition可以参考这篇文章——[V8 Ignition：JS 引擎与字节码的不解之缘](https://cnodejs.org/topic/59084a9cbbaf2f3f569be482)

## TurboFan：编译器

使用node命令的--print-code以及--print-opt-code选项，打印出TurboFan生成的汇编代码：

node --print-code --print-opt-code factorial.js

在Mac上运行的，结果如下图所示：

![rtQTi2](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/rtQTi2.png)

比起Bytecode，正真的汇编代码可读性差很多。而且，机器的CPU类型不一样的话，生成的汇编代码也不一样。

这些汇编代码就不用去管它了，因为最重要的是理解TurboFan是如何优化所生成的汇编代码的。我们可以通过add函数来梳理整个优化过程。

```js
function add(x, y) {
    return x + y;
}

add(1, 2);
add(3, 4);
add(5, 6);
add("7", "8");
```

由于JS的变量是没有类型的，所以add函数的参数可以是任意类型：Number、String、Boolean等，这就意味着add函数可能是数字相加(V8还会区分整数和浮点数)，可能是字符串拼接，也可能是其他更复杂的操作。如果直接编译的话，生成的代码比如会有很多if...else分支，伪代码如下：

```js
if (isInteger(x) && isInteger(y)) {
    // 整数相加
} else if (isFloat(x) && isFloat(y)) {
    // 浮点数相加
} else if (isString(x) && isString(y)) {
    // 字符串拼接
} else {
    // 各种其他情况
}
```

我只写了4个分支，实际上的分支其实更多，比如当参数类型不一致时还得进行类型转换，大家不妨看看ECMASCript对加法是如何定义的：12.8.3The Addition Operator ( + )。

如果直接按照伪代码去生成汇编代码，那生成的代码必然非常冗长，这样会占用很多内存空间。

Ignition在执行add(1, 2)时，已经知道add函数的两个参数都是整数，那么TurboFan在编译Bytecode时，就可以假定add函数的参数是整数，这样可以极大地简化生成的汇编代码，伪代码如下：

```js
if (isInteger(x) && isInteger(y)) {
    // 整数相加
} else {
    // Deoptimization
}
```

当然这样做也是有风险的，因为如果add函数参数不是整数，那么生成的汇编代码也没法执行，只能Deoptimize为Bytecode来执行。

也就是说，如果TurboFan对add函数进行编译优化的话，则add(3, 4)与add(3, 4)可以执行优化的汇编代码，但是add("7", "8")只能Deoptimize为Bytecode来执行。

当然，TurboFan所做的也不只是根据类型信息来简化代码执行流程，它还会进行其他优化，比如减少冗余代码等更复杂的事情。

由这个简单的例子可知，如果我们的JS代码中变量的类型变来变去，是会给V8引擎增加不少麻烦的，为了提高性能，我们可以尽量不要去改变变量的类型。

对于性能要求比较高的项目，使用TypeScript也是不错的选择，理论上，如果严格遵守类型化的编程方式，也是可以提高性能的，类型化的代码有利于V8引擎优化编译的汇编代码，当然这一点还需要测试数据来证明。

第一次执行字节码时，解释器会逐条解释执行，如果发现有热点代码（即一段代码被重复执行多次），编译器就会将这段热点代码编译为机器码保存起来，当再次执行这段代码时，只需要执行编译后的机器码；这种技术就叫做即时编译（JIT）。

![1595562271430-3aed7fff-1169-4812-9949-f97b5878061e](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/1595562271430-3aed7fff-1169-4812-9949-f97b5878061e.webp)

JIT 的作用就是尽可能结合解释器和编译器的优点，以使翻译代码和执行都能快速。

基本思想是尽可能避免重新翻译。首先，探测器通过解释器运行代码，在执行期间，探测器会追踪代码段并将其会被划分为 warm（运行少数几次） 和 hot（运行重复多次）。

JIT 把 warm 代码段直接丢给基准编译器，尽可能重用已编译的代码。

JIT 把 hot 代码段丢给优化编译器，其根据解释器收集来的信息（1）作出假设 和（2）基于假设（比如，对象属性始终以特定顺序出现）进行优化。

然而，一旦假设不成立，优化编译器就会进行 deoptimization 去优化，就是丢弃优化的代码。

优化和去优化的周期是昂贵的。由于需要存储优化过的机器码和探测器的信息，JIT 引入了额外的内存成本。这种成本激发了 V8 的解释器 Ignition 。

Ignition 将 AST 转换为字节码，字节码序列被执行，其反馈信息被 inline caches 内联高速缓存。 反馈信息被用于（1）Ignition 随后的解释 和（2）TurboFan 推测性优化。

TurboFan 基于反馈推测性的优化将字节码转换为机器码。

## Orinoco：垃圾回收

这里所说的垃圾，指的是程序中不再需要的内存空间，垃圾回收指的是回收这些不再需要的内存空间，让程序可以重新利用这些释放的内存空间。



## V8引擎和渲染引擎通信

![bVbq4Af](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/bVbq4Af.jpg)

当用户在屏幕上触发诸如 touch 等手势时，首先收到手势信息的是 Browser process， 不过 Browser process 只会感知到在哪里发生了手势，对 tab 内内容的处理是还是由渲染进程控制的。

事件发生时，浏览器进程会发送事件类型及相应的坐标给渲染进程，渲染进程随后找到事件对象，交给js引擎处理，如果js代码中利用了侨界接口将该节点绑定了事件监听，那么就会触发该事件监听函数。

