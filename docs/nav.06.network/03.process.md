# http握手与挥手

TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。

TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

![mxjdDF](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/mxjdDF.png)

## 三次握手

![5ySZfC](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/5ySZfC.png)

先预先了解下以下字段含义：

- ACK —— 确认，使得确认号有效。（也就是响应）
- RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。（也就是重连）
- SYN —— 用于初如化一个连接的序列号。（也就是建立连接）
- FIN —— 该报文段的发送方已经结束向对方发送数据。（也就是结束连接）

简单来说三次握手的目的就是建立tcp连接，确保客户端和服务器都能够正常通信（也就是发送报文和接收报文没问题）。

1. 第一次握手：客户端将标志位 SYN=1，随机产生一个值 seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT 状态，等待服务器端确认。这里可以理解为客户端单向想要和服务器建立连接，同时也确定了客户端发送功能没问题。
2. 第二次握手：服务器收到客户端发送的报文，由于标志位 SYN=1，也就知道是要请求建立连接，于是服务器将标志位 SYN 和 ACK 都设为1，随机产生一个值 seq=y ， ack = x+1 并将该数据包发送给客户端，服务器端进入SYN_RCVD 状态。这里可以理解通过以上方式，服务器也单向想要和客户端建立连接，同时也确定了服务器发送能力和接收能力没问题。
3. 第三次握手：客户端收到了服务器发送的报文，由于标志位 SYN 和 ACK 都为1，检查ack是否为x+1，如果正确则将标志位 ACK 置为 1， ack = y + 1，并将该数据包发送给服务器端，服务器端检查 ack 是否为 y+1，ACK 是否为 1，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。这里可以理解通过以上方式，双法都知道对方的发送报文和接收报文没问题。

## 四次挥手

![xTTB3X](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/xTTB3X.png)

假设关闭连接请求是由客户端发起的：

1. 第一次挥手：客户端发送 FIN=1，seq=x 的包给服务端，表示自己没有数据要进行传输，单面连接传输要关闭。发送完后，客户端进入 FIN_WAIT_1 状态。
2. 第二次挥手：服务端收到请求包后，发回 ACK=1,ack=x+1 的确认包，表示确认断开连接。服务端进入 CLOSE_WAIT 状态。客户端收到该包后，进入 FIN_WAIT_2 状态。此时客户端到服务端的数据连接已断开。
3. 第三次挥手：服务端发送 FIN=1,seq=y 的包给客户端，表示自己没有数据要给客户端了。发送完后进入 LAST_ACK 状态，等待客户端的确认包。
4. 第四次挥手：客户端收到 FIN=1 报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 ack=y+1 后进入 TIME_WAIT 状态，如果服务端没有收到 ACK 则可以重传。服务器端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

上图中有几个状态位有几个需要解释一下：

FIN_WAIT_1：FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 FIN 报文。而这两种状态的区别是：FIN_WAIT_1 状态实际上是当 SOCKET 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 FIN 报文，此时该 SOCKET 即进入到 FIN_WAIT_1 状态。而当对方回应 ACK 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应 ACK 报文，所以 FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。

TIME_WAIT: 表示收到了对方的 FIN 报文，并发送出了ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 FIN 标志和 ACK 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。

MSL(最大分段生存期)：指 TCP 报文在 Internet 上最长生存时间，每个具体的 TCP 实现都必须选择一个确定的 MSL 值。RFC 1122 建议是 2 分钟,但 BSD 传统实现采用了 30 秒。TIME_WAIT 状态最大保持时间是 2 * MSL,也就是 1-4 分钟。

## 答疑

### 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN （ ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭 SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。

### 为什么 TIME_WAIT 状态还需要等 2MSL 后才能返回到 CLOSED 状态？

虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的 ACK 报文会一定被对方收到，因此对方处于 LAST_ACK 状态下的 SOCKET 可能会因为超时未收到 ACK 报文，而重发 FIN 报文，所以这个 TIME_WAIT 状态的作用就是用来重发可能丢失的 ACK 报文。由于服务器等待超时重发FIN和FIN传输到达客户端的时间最大不超过 2MSL ，所以设计要等待 2MSL 后才能返回到 CLOSED 状态。
