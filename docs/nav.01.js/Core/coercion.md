# 强制类型转换

看完了《你不知道的JavaScript中卷》,其中的强制类型转换老是记得比较混乱，这里做个笔记总结下。

强制类型转换这一章节一共分为6个小节，分别是：

- 值类型转换
- 抽象值操作
- 显式强制类型转换
- 隐式强制类型转换
- 宽松相等和严格相等
- 抽象关系比较

那么下面我就好好总结下。

## 值类型转换

类型转换和强制类型转换的区别在于一个是显式的，一个是隐式的。

我们也可以这样理解，类型转换发生在静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时。所以在js我们通常将其统称为强制类型转换。

**js中的强制类型转换总是会返回标量的基本类型值，也就是字符串、数字和布尔值。**

## 抽象值操作

这小节我们掌握字符串、数字和布尔值之间类型换的基本规则，在ES5规范中，规则有如下四种：

- toString
- toNumber
- toPrimitive
- toBoolean

### toString

toString负责处理非字符串到字符串的强制类型转换。

基本规则如下：

- null: 转化为"null"
- undefined: 转换为"undefined"
- 布尔值: 转换为"true"或"false"
- 数字: 数字转换就是给数字叫上引号，不过需要注意的是极大或极小的数字，会用指数表示。

  ```js
  var num = Number.MAX_VALUE
  num.toString()//"1.7976931348623157e+308"
  ```

- 普通对象: 除非自行定义toString方法，否则将返回内部属性`[[Class]]`的值，如"[object Object]"
- 数组: 数组的默认toString方法经过了重新定义，**所有单元会用','连接起来，其实toString方法内部就是用了数组的join()方法**。我们可以做个测试：

  ```js
  var arr = [1,2,3]
  console.log(arr.toString()) //1,2,3
  arr.join = arr.shift;  
  console.log(arr.length) //3
  console.log(arr == 1 && arr == 2 && arr == 3) //true
  console.log(arr.length) //0
  ```

### toNumber

有时我们需要将非数字数值当做数字来使用，比如数学运算。具体规则如下：

- null: 转换为0
- undefined: 转换为NaN
- 布尔值: true转为1，false转为0
- 字符串: 如"123.1"转换为123.1，"213.3."或者"null"之类的一看就不是数字就转为NaN
- 对象(包含数组): **首先会转换为相应的基本类型值，如果返回的是非数字的基本类型值，则在遵循以上规则进行转换。转换为相应的基本类型值的规则看toPrimitive。**

### toPrimitive

这个小节我先于toBoolean记录，便于前后的理解

**toPrimitive抽象操作会首先检查值是否有valueOf()方法，如果有且返回基本类型值，就使用该值进行强制类型转换，如果没有就是用toString()的返回值进行强制类型转换，如果toString()也没有就会产生TypeError的报错。**

你可能一时间想不到什么值既没有valueOf()也没有toString()，那我来帮帮你，使用Object.create(null)创建的对象，因为[[prototype]]为null,所以他们没有这两个方法。

### toBoolean

toBoolean的转换规则就两条：

1. 可以被强制类型转换为false的值
2. 除了1，其他都可以转为true。

可以被强制类型转换为false的值为以下几种：

- undefined
- null
- +0,-0,NaN
- ""
- false

除了以上这五种，其他转换后均为真值。

**这里需要注意的是，Boolean构造函数生成的假值对象，他与普通对象差不多，但是在强制类型转换时，他们布尔值为false。**

```js
var a = new Boolean('');
console.log(a - 1) // -1,这里进行toPrimitive，先是valueOf为false，接着转为0
console.log(a == true) // true, 这里对象不属于可以被强制类型转换为false的值，所以为true
```

## 显式强制类型转换

显式强制类型转换顾名思义就是显而易见的，这里的显式只是主观存在的，你看得懂的都可以认为是显式。所以这里就记录一些大部分人都知道的强制类型转换。

### 数字与字符串

- 内建函数的显式转换

  ```js
  var a = 1;
  String(a) // "1"
  var b = "1.1"
  Number(b) // 1.1
  ```

- 日期显式转为数字

  ```js
  var d = +new Date()
  ```

- `~`运算符显式转为数字

  **`~`运算符可以理解为：~x = -(x+1)**

  ```js
  var a = '123'
  ~a //-124
  ~a.indexOf('4') //0
  ```

这里需要说下，解析和转换是两码事，解析运行字符串内含有非数字，因为他们从左到右执行，遇到非字符串就停。而转换不允许，会返回NaN。

解析我们最常用的可能就是parseInt和parseFloat这两个函数，想要具体了解自己看API，提示一下这两函数接受的是字符串，你传入其他类型他们也会先转为字符串。

### 转换为布尔值

- 内建函数的显式转换

  ```js
  Boolean("") //false
  Boolean("0") //true
  ```

- `!`运算符

  `!`运算符可以显式地将值进行强制类型转换为布尔值

- `？：`三元运算符

  ```js
  var a = '';
  var b = a?true:false //false,a会进行强制类型转换
  ```

## 隐式强制类型转换

隐式强制类型转换顾名思义，就是你不太知道的，所以一般情况下使用不当或者不知情的情况下会产生很多副作用。

### 字符串和数字

- `+`运算符

  **`+`运算符规则是两个操作数如果其中有一个是字符串，或者通过toPrimitive能够得到字符串，那么就执行字符串拼接，否则就执行加法运算。**

  ```js
  []+{} //'[object,Object]',因为两个操作数都可以通过toPrimitive能够得到字符串，[]得到‘’，{}得到[object,Object]
  {}+[] //0,因为{}被当做是代码块，所有只有有+[],那么就只能是通过toNumber的规则转为0
  ```

- `-`运算符

  `-`运算符就是直接执行减法运算，所有两个操作数必须都为数字，或者强制类型转换为数字。

### `||`和`&&`

**逻辑运算符`||`和`&&`左边的操作数如果不是布尔值就会做强制类型转换，要注意的是，这两个逻辑运算符并不一定返回的是布尔类型，而是两个操作数中的一个。**

**`||`和`&&`首先会对第一个操作数执行条件判断，对于`||`来说，如果条件判断是true，就返回第一个操作数，如果为false就返回第二个操作数。`&&`则相反。**

```js
var a = 1;
var b = null;
var c = 'false';
if(a&&(b||c)){
  console.log(true) // true
}
```

上面代码，其实`a&&(b||c)`返回的是'false',然后再将'false'做强制类型转换为true。

## 宽松相等和严格相等

宽松相等和严格相等其实指的就是`==`和`===`，**`==`允许在相等比较的时候做强制类型转换，而`===`不允许。**

- NaN和NaN: false,不相等
- -0和+0: true,相等
- **字符串和数字: 字符串做toNumber转换**
- **其他类型和布尔类型: 布尔类型做toNumber转换**
- null和undefined: true,他两相等，除此之外其他值都不和他两相等
- **对象和非对象: 对象做toPrimitive转换，然后根据上面规则。**
- **对象和对象：会使用严格比较**

![w4TD07](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/w4TD07.png)

这里截了一张MDN的图，方便参考。

## 抽象关系比较

比较关系的话，如果比较双方都是字符串或者通过toPrimitive得出字符串那么根据字母排序顺序比较，否则双方通过toPrimitive得出非字符串，然后根据toNumber作比较。

```js
var a = {c : 1}
var b = {c : 2}

a < b //false
a > b //false
a <= b //true
a >= b //true
```

上面代码可以这样理解，**a和b通过toPrimitive得出字符串`[object,Object]`,然后`a<=b`可以理解为`!(a>b)`,所以为true。**

啊！累死了，已经凌晨两点了！早点睡了！
