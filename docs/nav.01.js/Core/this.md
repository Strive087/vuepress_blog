# this你会用吗

this是执行上下文中的一个属性，this与上下文中可执行代码的类型有直接关系，this值在进入上下文时确定，并且在上下文运行期间永久不变。这里需要牢记！

## 全局代码

在全局代码中this始终指向全局对象！

## 函数代码

这种类型的代码中，this值的首要特点（或许是最主要的）是它不是静态的绑定到一个函数。他是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )。this取决于调用函数的方式。

不管怎样，在代码运行时的this值是不变的，也就是说，因为它不是一个变量，就不可能为其分配一个新值。需要重点记住，不是变量，无法赋值！

### this内部分析

可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。

```js
var valueOfReferenceType = {
  base: <base object>,
  propertyName: <property name>
};
```

引用类型的值只有两种情况：

1. 当我们处理一个标示符时
2. 或一个属性访问器

在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。

### 作为构造器调用的函数中的this

```js
function A() {
  alert(this); // "a"对象下创建一个新属性
  this.x = 10;
}
 
var a = new A();
alert(a.x); // 10s
```

new运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。 所有相同的函数“A”都将this的值设置为新创建的对象。

### 手动设置this

call、apply函数可以手动设置this
