# 事件循环机制

众所周知，JavaScript是单线程，非阻塞的。

JavaScript的主要用途是与用户互动，以及操作DOM。如果它是多线程的会有很多复杂的问题要处理，比如有两个线程同时操作DOM，一个线程删除了当前的DOM节点，一个线程是要操作当前的DOM阶段，最后以哪个线程的操作为准？为了避免这种，所以JS是单线程的。即使H5提出了web worker标准，它有很多限制，受主线程控制，是主线程的子线程。

而非阻塞则是通过事件循环（event loop）实现的。

因为ECMAScript中没有event loops，event loops是在HTML Standard定义的，所以准确的说应该叫浏览器的event loops或者说是javaScript运行环境的event loops。

## 浏览器环境

### 执行栈

我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。

![9Hj2Lm](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/9Hj2Lm.gif)

当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

### 消息队列与事件循环

以上的过程说的都是同步代码的执行。那么当一个异步代码（如发送ajax请求数据）执行后会如何呢？前文提过，js的另一大特点是非阻塞，实现这一点的关键在于下面要说的这项机制——消息队列。

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为消息队列。被放入消息队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找消息队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

![XdO77z](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/XdO77z.png)

图中的stack表示我们所说的执行栈，web apis则是代表一些异步事件，而callback queue即消息队列。

浏览器本身需要异步的场景非常多，而每一种异步操作的机制也各不相同，  消息队列可以和多种异步场景产生交互。

- 输入事件相关的异步交互（比如onClick）由引擎的 DOM Binding 模块处理，相应的事件触发时，会将对应的回调函数添加到消息队列中。
- ajax请求相关的异步交互 由引擎的network模块处理，在网络请求完成返回之后，会将对应的回调函数添加到消息队列中。
- 定时器相关的异步交互 会引擎的 timer 模块处理，当时间到达的时候，会将回调函数添加到任务队列中。（定时器调度策略比较复杂，会有专门的调度策略在合适的时间添加对应的回调任务）

以及一些其他的模块会将异步操作放置到消息队列中，在引擎主线程的任务都执行完成后再执行消息队列中被推送的任务。

### 消息队列执行细节

当闲置的时候，消息队列中的代码就会放入栈中执行。每次执行栈中的代码就是一个宏任务(task)，而消息队列中的任务会按顺序放到下一次的宏任务(task)中，每个宏任务(task)在执行时，V8 都会重新创建栈，然后随着宏任务(task)中函数调用，栈也随之变化，最终，当该宏任务(task)执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务(task)。

而浏览器会在一个 宏任务(task) 执行结束后，在下一个 task 执行开始前，对页面进行重新渲染如图：

![172f4a8db1a3c472](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/172f4a8db1a3c472.jpg)

由于主线程执行消息队列中宏任务的时间颗粒度太粗了（主要中间有一次渲染过程），无法胜任一些对精度和实时性要求较高的场景，所以又引入了promise 机制也就是微任务如图:

![172f4b0937bc892e](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/172f4b0937bc892e.jpg)

## nodejs环境
