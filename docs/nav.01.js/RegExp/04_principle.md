# 原理

正则表达式的运行分为如下的阶段：

1. 编译
2. 设定起始位置
3. 尝试匹配
4. 匹配失败的话，从下一位开始继续第3步
5. 最终结果：匹配成功或失败

下面以代码为例，来看看这几个阶段都做了什么：

```js
var regex = /\d+/g;
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
console.log( regex.lastIndex, regex.exec("123abc34def") );
// => 0 ["123", index: 0, input: "123abc34def"]
// => 3 ["34", index: 6, input: "123abc34def"]
// => 8 null
// => 0 ["123", index: 0, input: "123abc34def"]
```

分析如下：

```js
var regex = /\d+/g;
```

当生成一个正则时，引擎会对其进行编译。报错与否出现这这个阶段。

```js
regex.exec("123abc34def")
```

当尝试匹配时，需要确定从哪一位置开始匹配。

一般情形都是字符串的开头，即第0位。但当使用test和exec方法，且正则有g时，起始位置是从正则对象的lastIndex属性开始。

因此第一次exec是从第0位开始，而第二次是从3开始的。设定好起始位置后，就开始尝试匹配了。

比如第一次exec，从0开始，去尝试匹配，并且成功地匹配到3个数字。此时结束时的下标是2，因此下一次的起始位置是3。

而第二次，起始下标是3，但第3个字符是“a”，并不是数字。但此时并不会直接报匹配失败，而是移动到下一位置，即从第4位开始继续尝试匹配，但该字符是b，也不是数字。再移动到下一位，是c仍不行，再移动一位是数字3，此时匹配到了两位数字34。此时，下一次匹配的位置是d的位置，即第8位。

第三次，是从第8位开始匹配，直到试到最后一位，也没发现匹配的，因此匹配失败，返回null。同时设置lastIndex为0，即，如要再尝试匹配的话，需从头开始。从上面可以看出，匹配会出现效率问题，主要出现在上面的第3阶段和第4阶段。

[JS正则表达式完整教程](https://juejin.cn/post/6844903487155732494#heading-32)
