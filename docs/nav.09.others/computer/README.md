# 核心、进程与线程

## 核心与进程

![Ht0Q0C](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/Ht0Q0C.jpg)

对于多核心的架构，由于共用一套MMU和cache，所以地址空间是一个，同一时刻只能运行一个进程，此时进程不能并行只能并发。同一个进程下的多线程可以并行执行，因为多线程共享同一套进程空间资源。

![EuHKEl](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/EuHKEl.jpg)

对于多cpu架构可以支持进程并行。

## 进程与线程

![16f3c73a8910422c](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c73a8910422c.jpg)

进程可以看成正在被执行的应用程序（executing program）。而线程是跑在进程里面的，一个进程里面可能有一个或者多个线程，这些线程可以执行任何一部分应用程序的代码。

![16f3c7459517f505](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c7459517f505.jpg)

当你启动一个应用程序的时候，操作系统会为这个程序创建一个进程同时还为这个进程分配一片私有的内存空间（虚拟内存空间，只有你正在使用了才占有），这片空间会被用来存储所有程序相关的数据和状态。当你关闭这个程序的时候，这个程序对应的进程也会随之消失，进程对应的内存空间也会被操作系统释放掉。

![16f3c748005df430](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c748005df430.jpg)

时候为了满足功能的需要，创建的进程会叫系统创建另外一些进程去处理其它任务，不过新建的进程会拥有全新的独立的内存空间而不是和原来的进程共用内存空间。如果这些进程需要通信，它们要通过IPC机制（Inter Process Communication）来进行。很多应用程序都会采取这种多进程的方式来工作，因为进程和进程之间是互相独立的它们互不影响，换句话来说，如果其中一个工作进程（worker process）挂掉了其他进程不会受到影响，而且挂掉的进程还可以重启。

## 三者关系详解

1. 计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位)，由于超线程技术，实际上可以并行的线程数量通常是物理核数的两倍，这也是操作系统看到的核数。我们只care可以并行的线程数量，所以之后所说的核数是操作系统看到的核数，所指的核也是超线程技术之后的那个核（不是物理核）。

2. 进程是操作系统资源分配（内存，显卡，磁盘）的最小单位，线程是执行调度（即cpu调度）的最小单位（cpu看到的都是线程而不是进程），一个进程可以有一个或多个线程，线程之间共享进程的资源，通过这样的范式，就可以减少进程的创建和销毁带来的代价，可以让进程少一点，保持相对稳定，不断去调度线程就好。如果计算机有多个cpu核，且计算机中的总的线程数量小于核数，那线程就可以并行运行在不同的核中，如果是单核多线程，那多线程之间就不是并行，而是并发，即为了均衡负载，cpu调度器会不断的在单核上切换不同的线程执行，但是我们说过，一个核只能运行一个线程，所以并发虽然让我们看起来不同线程之间的任务是并行执行的，但是实际上却由于增加了线程切换的开销使得代价更大了。如果是多核多线程，且线程数量大于核数，其中有些线程就会不断切换，并发执行，但实际上最大的并行数量还是当前这个进程中的核的数量，所以盲目增加线程数不仅不会让你的程序更快，反而会给你的程序增加额外的开销。

3. 任务可以分为计算密集型和IO密集型，假设我们现在使用一个进程来完成这个任务，对计算密集型任务，可以使用【核心数】个线程，就可以占满cpu资源，进而可以充分利用cpu，如果再多，就会造成额外的开销；对于IO密集型任务（涉及到网络、磁盘IO的任务都是IO密集型任务），线程由于被IO阻塞，如果仍然用【核心数】个线程，cpu是跑不满的，于是可以使用更多个线程来提高cpu使用率。

4. 实现并行计算有三种方式，多线程，多进程，多进程+多线程。如果是多进程，因为每个进程资源是独立的（地址空间和数据空间），就要在操作系统层面进行通信，如管道，队列，信号等；多线程的话会共享进程中的地址空间和数据空间，一个线程的数据可以直接提供给其他线程使用，但方便的同时会造成变量值的混乱，所以要通过线程锁来限制线程的执行。
