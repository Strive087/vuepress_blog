# 手写代码

## js并发请求

```js
function createRequest({pool = 2}){
  let queueLength = 0;
  let waitingQueue = [];
  return function request(url){
      if(queueLength < pool && url){
          queueLength++;
          fetch(url).then(()=>{
              queueLength--;
              request(waitingQueue.shift());
          })
      }else{
          waitingQueue.push(url);
      }
  }
}
const request = createRequest({ pool: 4 });
Array(10)
.fill(1)
.forEach(() => request("https://mock.yonyoucloud.com/mock/17479/czzp-demo/getMenus"))
```

## 随机生成一段Json

```js
//最大层级level，最大子数目maxChildren，数值任意
function generateJson(level = 1,maxChildren = 1){
  if(level < 1){
    return Math.round(Math.random()*10);
  }
  let json = {};
  let randomChildrenNum = Math.round(Math.random()*maxChildren) || 1;
  let randomChildrenlevel = Math.round(Math.random()*randomChildrenNum) || 1;
  for(let j = 1; j <= randomChildrenNum - randomChildrenlevel; j++){
    json['val'+j] = Math.round(Math.random()*10);
  }
  for(let k = 1; k <= randomChildrenlevel; k++){
    json['val'+k] = generateJson(--level,maxChildren);
  }
  return json;
}
console.log(JSON.stringify(generateJson(3,4),null,2));
```

## 深度不定的树形数据，给一个节点，输出从根节点到当前节点的路径

```js
function getNodePath(root, node) {
  let path = "",pathArr = [];
  if (root) {
    _getNodePath(root)
    console.log(pathArr);
  }
  function _getNodePath(root) {
    const str = "->" + root.value;
    path += str;
    if (root.value == node.value && contrast(node, root)) {
      pathArr.push(path.slice(2));
    }
    if (root.left) _getNodePath(root.left);
    if (root.right) _getNodePath(root.right);
    path = path.substr(0, path.length - str.length);
  }
  function contrast(node, currentNode) {
    if (node == null && currentNode == null) {
      return true;
    }
    if (node && currentNode && node.value == currentNode.value) {
      return (
        contrast(node.left, currentNode.left) &&
        contrast(node.right, currentNode.right)
      );
    } else {
      return false;
    }
  }
}

var root = JSON.parse(
  `{
    "value": 0,
    "right": {
      "value": 1,
      "left": {
        "value": 2,
        "left": {
          "value": 3,
          "right": {
            "value": 4,
            "left": {
              "value": 5,
              "left": {
                "value": 6,
                "left": {
                  "value": 8,
                  "left": {
                    "value": 11
                  },
                  "right": {
                    "value": 12
                  }
                },
                "right": {
                  "value": 9
                }
              },
              "right": {
                "value": 7,
                "right": {
                  "value": 10
                }
              }
            }
          }
        }
      }
    }
  }`
);
var node = JSON.parse(`{
  "value": 6,
  "left": {
    "value": 8,
    "left": {
      "value": 11
    },
    "right": {
      "value": 12
    }
  },
  "right": {
    "value": 9
  }
}`);

getNodePath(root, node);
```

## 手写Promise.all() polyfill

```js
function _PromiseAll(arr) {
  const result = Array(arr.length);
  let doneNum = 0;
  return new Promise(function (resolve) {
    arr.forEach((p,i) => {
      p.then((res) => {
        result[i] = res;
      }).catch((err) => {
        result[i] = err;
      }).finally(() => {
        if(++doneNum == result.length){
          resolve(result);
        }
      });
    });
  })
}

var p1 = new Promise(function (resolve){
  setTimeout(()=>{
    resolve('p1')
  },1000);
})
var p2 = new Promise(function (resolve){
  setTimeout(()=>{
    resolve('p2')
  },2000);
})
var p3 = new Promise(function (resolve){
  setTimeout(()=>{
    resolve('p3')
  },3000);
})

var p4 = _PromiseAll([p1,p2,p3]);
p4.then(res=>console.log(res));

```

## 手写Promise.race() polyfill

```js
function _PromiseRace(arr){
  return new Promise((resolve,reject) => {
    arr.forEach(p=>{
      p.then(val => resolve('fulfilled:'+val),err => reject('reject:'+err));
    })
  })
}

var p1 = new Promise(function (resolve,reject) {
  setTimeout(()=>{
    reject('p1')
  },1000);
})
var p2 = new Promise(function (resolve){
  setTimeout(()=>{
    resolve('p2')
  },2000);
})
var p3 = new Promise(function (resolve){
  setTimeout(()=>{
    resolve('p3')
  },3000);
})

var p4 = _PromiseRace([p1,p2,p3]);
p4.then(res=>console.log(res));
```

## 手写Promise polyfill

```js
function _Promise(fn) {
  this.state = "pending";
  this.val = null;
  this.fulfilledQueue = [];
  this.rejectedQueue = [];
  if (typeof fn !== "function") {
    throw new Error("param must be a function");
  }
  const resolve = (val) => {
    if (this.state === "pending") {
      const run = () => {
        if (val instanceof _Promise) {
          //这里将产生一个Promise，但这个promise只是为了得出当前promise的状态和值，并无其他用处
          val.then(resolve, reject);
        } else {
          this.state = "fulfilled";
          this.val = val;
        }
        while (this.fulfilledQueue.length) {
          const cb = this.fulfilledQueue.shift();
          //这里需要注意，这里的val要根据回调执行时的val，不可绑定this通过this.val取值
          cb(val);
        }
      };
      setTimeout(() => run());
    }
  };
  const reject = (val) => {
    if (this.state === "pending") {
      const run = () => {
        this.state = "rejected";
        this.val = val;
        while (this.rejectedQueue.length) {
          const cb = this.rejectedQueue.shift();
          cb(val);
        }
      };
      setTimeout(() => run());
    }
  };
  try {
    fn.call(this, resolve, reject);
  } catch (err) {
    reject(err);
  }
}

_Promise.prototype.then = function (onFulfilled, onRejected) {
  onFulfilled = typeof onFulfilled !== "function" ? val => val : onFulfilled;
  onRejected = typeof onRejected !== "function" ? val => {throw val} : onRejected;
  return new _Promise((resolve, reject) => {
    const fulfilled = function(val){
      try {
        res = onFulfilled(val);
        if (res instanceof _Promise) {
          res.then(resolve, reject);
        } else {
          resolve(res);
        }
      } catch (err) {
        reject(err);
      }
    };
    const rejected = function(val){
      try {
        res = onRejected(val);
        if (res instanceof _Promise) {
          res.then(resolve, reject);
        } else {
          resolve(res);
        }
      } catch (err) {
        reject(err);
      }
    };
    if (this.state === "pending") {
      //这里需要注意，这里的val要根据回调执行时的val，不可绑定this通过this.val取值
      this.fulfilledQueue.push(fulfilled);
      this.rejectedQueue.push(rejected);
    } else if (this.state === "fulfilled") {
      fulfilled(this.val);
    } else {
      rejected(this.val);
    }
  });
};

_Promise.prototype.catch = function (onRejected) {
  return this.then(undefined, onRejected);
};

_Promise.prototype.finally = function (fn) {
  return this.then(
    (val) => {
      fn();
      return val;
    },
    (val) => {
      fn();
      throw val;
    }
  );
};

let promise1 = new _Promise((resolve, reject) => {
  console.log('first')
    reject("p1");
   
});

let promise2 = new _Promise((resolve, reject) => {
  setTimeout(() => {
    //参数为promise
    resolve(promise1);
  }, 1000);
});

const p = new _Promise((resolve, reject) => {
  resolve("p1 resolve");
})
  .then((val) => {
    console.log(val);
    throw new Error("p2 reject");
  })
  .catch((val) => {
    console.log(val);
    throw "errrr";
  })
  .finally(() => {
    console.log('ASDFASDF');
  })
  .then((val) => {
    console.log(val);
  })
  .catch((err) => {
    console.log(err);
  });
console.log(111);
```

## 手写Promise.resolve()

```js
_Promise.resolve = function ( val ) {
  return new _Promise(resolve => resolve(val));
};
```

## 手写Promise.reject()

```js
_Promise.reject = function (val) {
  return new _Promise((resolve ,reject) => reject(val))
}
```

## 实现迭代器

```js
function createIterator(items) {
  var i = 0;
  return {
    next: function () {
      var done = i >= items.length;
      var value = !done ? items[i++] : undefined;
      return {
        done: done,
        value: value
      };
    },
    [Symbol.iterator]: function () {
      return this;
    }
  };
}

Object.prototype[Symbol.iterator] = function* () {
  for (const key in this) {
      if (this.hasOwnProperty(key)) {
          yield [key, this[key]]
      }
  }
}

// 应用
const iterator = createIterator([1, 2, 3]);
const obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4
};
for (let a of iterator) {
  console.log(a);
}
for (let a of obj) {
  console.log(a);
}
```

## 手写Generator自动执行器

```js
```

## 手写bind()
