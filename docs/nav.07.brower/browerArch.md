# 浏览器架构

在了解浏览器架构之前我们需要知道进程与线程的[相关预备知识](../nav.08.others/computer/README.md)。

浏览器架构分为单进程架构和多进程架构。单进程架构下会启动多线程运行。而多进程架构下各个进程之间通过IPC进程通信。

![16f3c74bbaab2c5f](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c74bbaab2c5f.jpg)

然而现实情况是各个浏览器并没有统一的规范，我们这里以chrome浏览器为例进行分析。

chrome浏览器采用的多进程的架构，架构图如下：

![16f3c74e48d4637d](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c74e48d4637d.jpg)

Chrome浏览器会有一个浏览器进程（browser process），这个进程会和其他进程一起协作来实现浏览器的功能。对于渲染进程（renderer process），Chrome会尽可能为每一个tab甚至是页面里面的每一个iframe都分配一个单独的进程。

## 进程分工

|  进程          | 分工           |
| -------------- |:-------------:|
|Browser         | 负责浏览器的“Chrome”部分， 包括导航栏，书签， 前进和后退按钮。同时这个进程还会控制那些我们看不见的部分，包括网络请求的发送以及文件的读写。|
|Utility         | 实用进程负责网络、存储等服务，配合浏览器进程工作
|Renderer        |负责tab内和网页展示相关的所有工作。|
|Plugin          | 控制网页使用的所有插件，例如flash插件。 |
|GPU             | 负责独立于其它进程的GPU任务。它之所以被独立为一个进程是因为它要处理来自于不同tab的渲染请求并把它在同一个界面上画出来。|

![16f3c750b4526538](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c750b4526538.jpg)

## 多进程架构的优缺点

其中一个优点是多进程可以使浏览器具有很好的容错性。对于大多数简单的情景来说，Chrome会为每个tab单独分配一个属于它们的渲染进程（render process）。举个例子，假如你有三个tab，你就会有三个独立的渲染进程。当其中一个tab的崩溃时，你可以随时关闭这个tab并且其他tab不受到影响。可是如果所有的tab都跑在同一个进程的话，它们就会有连带关系，一个挂全部挂。

![16f3c75540ca2758](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c75540ca2758.jpg)

采用多进程架构的另外一个优点就是可以提供安全性和沙盒性（sanboxing）。因为操作系统可以提供方法让你限制每个进程拥有的能力，所以浏览器可以让某些进程不具备某些特定的功能。例如，由于tab渲染进程可能会处理来自用户的随机输入，所以Chrome限制了它们对系统文件随机读写的能力。

不过多进程架构也有它的缺点，那就是进程的内存消耗。由于每个进程都有各自独立的内存空间，所以它们不能像存在于同一个进程的线程那样共用内存空间，这就造成了一些基础的架构（例如V8 JavaScript引擎）会在不同进程的内存空间同时存在的问题，这些重复的内容会消耗更多的内存。所以为了节省内存，Chrome会限制被启动的进程数目，当进程数达到一定的界限后，Chrome会将访问同一个网站的tab都放在一个进程里面跑。还有一个缺点就是之前在相关预备知识中提到的进程与进程之间的资源访问代价大，需要比线程之间访问资源更耗费时间。

## Chrome的服务化

Chrome浏览器的架构正在发生一些改变，目的是将和浏览器本身（Chrome）相关的部分拆分为一个个不同的服务，服务化之后，这些功能既可以放在不同的进程里面运行也可以合并为一个单独的进程运行。

![ONt4ZF](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/ONt4ZF.png)

这样做的主要原因是让Chrome在不同性能的硬件上有不同的表现。当Chrome运行在一些性能比较好的硬件时，浏览器进程相关的服务会被放在不同的进程运行以提高系统的稳定性。相反如果硬件性能不好，这些服务就会被放在同一个进程里面执行来减少内存的占用。其实在这次架构变化之前，Chrome在Android上面已经开始采取类似的做法了。

## 单帧渲染进程 - 网站隔离

网站隔离（Site Isolation）是最近Chrome浏览器启动的功能，这个功能会为网站内不同站点的iframe分配一个独立的渲染进程。之前说过Chrome会为每个tab分配一个单独的渲染进程，可是如果一个tab只有一个进程的话不同站点的iframe都会跑在这个进程里面，这也意味着它们会共享内存，这就有可能会破坏同源策略。同源策略是浏览器最核心的安全模型，它可以禁止网站在未经同意的情况下去获取另外一个站点的数据，因此绕过同源策略是很多安全攻击的主要目的。而进程隔离（proces isolation）是隔离网站最好最有效的办法了。再加上CPU存在Meltdown和Spectre的隐患，网站隔离变得势在必行。因此在Chrome 67版本之后，桌面版的Chrome会默认开启网站隔离功能，这样每一个跨站点的iframe都会拥有一个独立的渲染进程。

![16f3c75babbafb04](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/16f3c75babbafb04.jpg)

## 渲染进程的多线程机制

![uEELI7](https://zhuduanlei-1256381138.cos.ap-guangzhou.myqcloud.com/uPic/uEELI7.png)

1. GUI渲染线程

    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
    - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结 了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2. JS引擎线程

    - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
    - JS引擎线程负责解析Javascript脚本，运行代码。
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    - 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. 事件触发线程

    - 归属于浏览器而不是JS引擎，用来控制事件循环。
    - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4. 定时触发器线程

    - 传说中的setInterval与setTimeout所在线程
    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。（也就是0ms也算4ms）

5. 异步http请求线程

    - 在XMLHttpRequest连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。
